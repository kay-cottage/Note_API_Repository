<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ™ºèƒ½ç¬”è®°æ•´ç†å·¥å…·</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1rem;
        }

        .main-content {
            padding: 40px;
        }

        .section {
            margin-bottom: 40px;
            padding: 30px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 15px;
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        .section h2 {
            color: #374151;
            margin-bottom: 20px;
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .form-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
        }

        .form-group label {
            font-weight: 600;
            color: #374151;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .form-group input, .form-group select, .form-group textarea {
            padding: 12px 16px;
            border: 2px solid #e5e7eb;
            border-radius: 10px;
            font-size: 1rem;
            transition: all 0.3s ease;
            background: white;
        }

        .form-group input:focus, .form-group select:focus, .form-group textarea:focus {
            outline: none;
            border-color: #6366f1;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }

        .password-input {
            position: relative;
        }

        .password-toggle {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            color: #6b7280;
            font-size: 1.2rem;
        }

        .btn {
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(99, 102, 241, 0.3);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #10b981, #059669);
        }

        .btn-secondary:hover {
            box-shadow: 0 10px 20px rgba(16, 185, 129, 0.3);
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-ready { background: #10b981; }
        .status-processing { background: #f59e0b; animation: pulse 2s infinite; }
        .status-error { background: #ef4444; }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .log-container {
            background: #1f2937;
            color: #e5e7eb;
            border-radius: 10px;
            padding: 20px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            max-height: 400px;
            overflow-y: auto;
            border: 2px solid #374151;
        }

        .log-entry {
            margin-bottom: 8px;
            padding: 8px 12px;
            border-radius: 6px;
            border-left: 4px solid transparent;
        }

        .log-info { border-left-color: #3b82f6; background: rgba(59, 130, 246, 0.1); }
        .log-success { border-left-color: #10b981; background: rgba(16, 185, 129, 0.1); }
        .log-warning { border-left-color: #f59e0b; background: rgba(245, 158, 11, 0.1); }
        .log-error { border-left-color: #ef4444; background: rgba(239, 68, 68, 0.1); }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e5e7eb;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 15px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #6366f1, #8b5cf6);
            transition: width 0.3s ease;
            width: 0%;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            border: 2px solid rgba(99, 102, 241, 0.1);
        }

        .stat-number {
            font-size: 2rem;
            font-weight: 700;
            color: #6366f1;
            display: block;
        }

        .stat-label {
            color: #6b7280;
            margin-top: 5px;
            font-size: 0.9rem;
        }

        @media (max-width: 768px) {
            .header h1 { font-size: 2rem; }
            .main-content { padding: 20px; }
            .section { padding: 20px; }
            .form-grid { grid-template-columns: 1fr; }
        }

        .icon {
            width: 24px;
            height: 24px;
            fill: currentColor;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ¤– æ™ºèƒ½ç¬”è®°æ•´ç†å·¥å…·</h1>
            <p>åŸºäºAIçš„GitHubç¬”è®°è¯­ä¹‰ç´¢å¼•ä¸è‡ªåŠ¨æ•´ç†ç³»ç»Ÿ</p>
        </div>

        <div class="main-content">
            <!-- é…ç½®åŒºåŸŸ -->
            <div class="section">
                <h2>
                    <svg class="icon" viewBox="0 0 24 24">
                        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                    </svg>
                    APIé…ç½®
                </h2>
                <div class="form-grid">
                    <div class="form-group">
                        <label for="githubToken">GitHub API Token</label>
                        <div class="password-input">
                            <input type="password" id="githubToken" placeholder="ghp_xxxxxxxxxxxxxxxx">
                            <button type="button" class="password-toggle" onclick="togglePassword('githubToken')">ğŸ‘ï¸</button>
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="openaiKey">OpenAI API Key</label>
                        <div class="password-input">
                            <input type="password" id="openaiKey" placeholder="sk-xxxxxxxxxxxxxxxx">
                            <button type="button" class="password-toggle" onclick="togglePassword('openaiKey')">ğŸ‘ï¸</button>
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="githubUser">GitHubç”¨æˆ·å</label>
                        <input type="text" id="githubUser" placeholder="your-username">
                    </div>
                    <div class="form-group">
                        <label for="sourceRepo">æºä»“åº“å</label>
                        <input type="text" id="sourceRepo" placeholder="notes-repo">
                    </div>
                    <div class="form-group">
                        <label for="targetRepo">ç›®æ ‡ä»“åº“å</label>
                        <input type="text" id="targetRepo" placeholder="organized-notes-repo">
                    </div>
                    <div class="form-group">
                        <label for="gptModel">GPTæ¨¡å‹</label>
                        <select id="gptModel">
                            <option value="gpt-4o-mini">GPT-4o Mini (æ¨è)</option>
                            <option value="gpt-4o">GPT-4o</option>
                            <option value="gpt-4-turbo">GPT-4 Turbo</option>
                            <option value="gpt-3.5-turbo">GPT-3.5 Turbo</option>
                        </select>
                    </div>
                </div>
                <button class="btn" onclick="saveConfig()" style="margin-top: 20px;">
                    ğŸ’¾ ä¿å­˜é…ç½®
                </button>
            </div>

            <!-- æ“ä½œåŒºåŸŸ -->
            <div class="section">
                <h2>
                    <svg class="icon" viewBox="0 0 24 24">
                        <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                    </svg>
                    æ™ºèƒ½æ•´ç†æ§åˆ¶
                </h2>
                <div style="display: flex; gap: 15px; flex-wrap: wrap; align-items: center;">
                    <button class="btn btn-secondary" onclick="startProcessing()" id="processBtn">
                        ğŸš€ å¼€å§‹æ™ºèƒ½æ•´ç†
                    </button>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span class="status-indicator status-ready" id="statusIndicator"></span>
                        <span id="statusText">å°±ç»ª</span>
                    </div>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressBar"></div>
                </div>
            </div>

            <!-- ç»Ÿè®¡åŒºåŸŸ -->
            <div class="section">
                <h2>
                    <svg class="icon" viewBox="0 0 24 24">
                        <path d="M3 13h8V3H3v10zm0 8h8v-6H3v6zm10 0h8V11h-8v10zm0-18v6h8V3h-8z"/>
                    </svg>
                    å¤„ç†ç»Ÿè®¡
                </h2>
                <div class="stats-grid">
                    <div class="stat-card">
                        <span class="stat-number" id="totalFiles">0</span>
                        <div class="stat-label">æ€»æ–‡ä»¶æ•°</div>
                    </div>
                    <div class="stat-card">
                        <span class="stat-number" id="processedFiles">0</span>
                        <div class="stat-label">å·²å¤„ç†</div>
                    </div>
                    <div class="stat-card">
                        <span class="stat-number" id="skippedFiles">0</span>
                        <div class="stat-label">å·²è·³è¿‡</div>
                    </div>
                    <div class="stat-card">
                        <span class="stat-number" id="errorFiles">0</span>
                        <div class="stat-label">å¤„ç†å¤±è´¥</div>
                    </div>
                </div>
            </div>

            <!-- æ—¥å¿—ç®¡ç†åŒºåŸŸ -->
            <div class="section">
                <h2>
                    <svg class="icon" viewBox="0 0 24 24">
                        <path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-5 14H7v-2h7v2zm3-4H7v-2h10v2zm0-4H7V7h10v2z"/>
                    </svg>
                    æ—¥å¿—ç®¡ç†
                </h2>
                <div style="display: flex; gap: 15px; flex-wrap: wrap; margin-bottom: 20px;">
                    <button class="btn" onclick="viewHistoryLogs()" style="background: linear-gradient(135deg, #f59e0b, #d97706);">
                        ğŸ“š æŸ¥çœ‹å†å²æ—¥å¿—
                    </button>
                    <button class="btn" onclick="saveCurrentSession()" style="background: linear-gradient(135deg, #10b981, #059669);">
                        ğŸ’¾ ä¿å­˜å½“å‰ä¼šè¯
                    </button>
                    <button class="btn" onclick="clearCurrentLogs()" style="background: linear-gradient(135deg, #6b7280, #4b5563);">
                        ğŸ—‘ï¸æ¸…ç©ºå½“å‰æ—¥å¿—
                    </button>
                </div>
                <div class="log-container" id="logContainer">
                    <div class="log-entry log-info">ç³»ç»Ÿå·²å°±ç»ªï¼Œç­‰å¾…å¼€å§‹å¤„ç†...</div>
                </div>
            </div>

            <!-- å¤„ç†æ—¥å¿— -->
            <div class="section">
                <h2>
                    <svg class="icon" viewBox="0 0 24 24">
                        <path d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 2 2h12c1.1 0 2-.9 2-2V8l-6-6zm2 16H8v-2h8v2zm0-4H8v-2h8v2zm-3-5V3.5L18.5 9H13z"/>
                    </svg>
                    GitHubæ—¥å¿—çŠ¶æ€
                </h2>
                <div class="stats-grid">
                    <div class="stat-card">
                        <span class="stat-number" id="logStatus">ğŸ“</span>
                        <div class="stat-label">æ—¥å¿—çŠ¶æ€</div>
                    </div>
                    <div class="stat-card">
                        <span class="stat-number" id="sessionCount">0</span>
                        <div class="stat-label">å†å²ä¼šè¯</div>
                    </div>
                    <div class="stat-card">
                        <span class="stat-number" id="errorCount">0</span>
                        <div class="stat-label">é”™è¯¯è®°å½•</div>
                    </div>
                    <div class="stat-card" style="cursor: pointer;" onclick="exportReport()">
                        <span class="stat-number">ğŸ“Š</span>
                        <div class="stat-label">å¯¼å‡ºæŠ¥å‘Š</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let config = {};
        let isProcessing = false;
        let processedLog = new Set();
        let stats = {
            total: 0,
            processed: 0,
            skipped: 0,
            error: 0
        };

        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            loadConfig();
        });

        // é…ç½®ç®¡ç†
        function saveConfig() {
            config = {
                githubToken: document.getElementById('githubToken').value,
                openaiKey: document.getElementById('openaiKey').value,
                githubUser: document.getElementById('githubUser').value,
                sourceRepo: document.getElementById('sourceRepo').value,
                targetRepo: document.getElementById('targetRepo').value,
                gptModel: document.getElementById('gptModel').value
            };

            // ä¿å­˜åˆ°å†…å­˜ï¼ˆä¸ä½¿ç”¨localStorageï¼‰
            addLog('é…ç½®å·²ä¿å­˜', 'success');
        }

        function loadConfig() {
            // ä»å†…å­˜åŠ è½½é…ç½®ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
            if (Object.keys(config).length > 0) {
                document.getElementById('githubToken').value = config.githubToken || '';
                document.getElementById('openaiKey').value = config.openaiKey || '';
                document.getElementById('githubUser').value = config.githubUser || '';
                document.getElementById('sourceRepo').value = config.sourceRepo || '';
                document.getElementById('targetRepo').value = config.targetRepo || '';
                document.getElementById('gptModel').value = config.gptModel || 'gpt-4o-mini';
            }
        }

        function togglePassword(fieldId) {
            const field = document.getElementById(fieldId);
            const button = field.nextElementSibling;
            
            if (field.type === 'password') {
                field.type = 'text';
                button.textContent = 'ğŸ™ˆ';
            } else {
                field.type = 'password';
                button.textContent = 'ğŸ‘ï¸';
            }
        }

        // æ—¥å¿—ç®¡ç†
        function addLog(message, type = 'info') {
            const logContainer = document.getElementById('logContainer');
            const timestamp = new Date().toLocaleString();
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${type}`;
            logEntry.textContent = `[${timestamp}] ${message}`;
            
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        // çŠ¶æ€ç®¡ç†
        function updateStatus(text, status = 'ready') {
            document.getElementById('statusText').textContent = text;
            const indicator = document.getElementById('statusIndicator');
            indicator.className = `status-indicator status-${status}`;
        }

        function updateProgress(percent) {
            document.getElementById('progressBar').style.width = `${percent}%`;
        }

        function updateStats() {
            document.getElementById('totalFiles').textContent = stats.total;
            document.getElementById('processedFiles').textContent = stats.processed;
            document.getElementById('skippedFiles').textContent = stats.skipped;
            document.getElementById('errorFiles').textContent = stats.error;
        }

        // GitHub APIè°ƒç”¨
        async function githubRequest(endpoint, method = 'GET', body = null) {
            const url = `https://api.github.com${endpoint}`;
            const headers = {
                'Authorization': `token ${config.githubToken}`,
                'Accept': 'application/vnd.github.v3+json',
                'Content-Type': 'application/json'
            };

            const response = await fetch(url, {
                method,
                headers,
                body: body ? JSON.stringify(body) : null
            });

            if (!response.ok) {
                throw new Error(`GitHub API Error: ${response.status} ${response.statusText}`);
            }

            return await response.json();
        }

        // OpenAI APIè°ƒç”¨
        async function openaiRequest(messages, model = 'gpt-4o-mini') {
            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${config.openaiKey}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    model: model,
                    messages: messages,
                    temperature: 0.7,
                    max_tokens: 4000
                })
            });

            if (!response.ok) {
                throw new Error(`OpenAI API Error: ${response.status} ${response.statusText}`);
            }

            return await response.json();
        }

        // è·å–å¤„ç†æ—¥å¿—
        async function getProcessingLog() {
            try {
                const logFile = await githubRequest(`/repos/${config.githubUser}/${config.targetRepo}/contents/logs/processing_log.md`);
                const content = atob(logFile.content);
                return content.split('\n').filter(line => line.trim());
            } catch (error) {
                if (error.message.includes('404')) {
                    return []; // æ—¥å¿—æ–‡ä»¶ä¸å­˜åœ¨
                }
                throw error;
            }
        }

        // æ›´æ–°å¤„ç†æ—¥å¿—
        async function updateProcessingLog(filename, status = 'success', details = '') {
            const timestamp = new Date().toISOString();
            const logEntry = `${filename} | ${status} | ${timestamp} | ${details}`;
            
            try {
                const logFile = await githubRequest(`/repos/${config.githubUser}/${config.targetRepo}/contents/logs/processing_log.md`);
                const existingContent = atob(logFile.content);
                const newContent = existingContent + '\n' + logEntry;
                
                await githubRequest(`/repos/${config.githubUser}/${config.targetRepo}/contents/logs/processing_log.md`, 'PUT', {
                    message: `Update processing log for ${filename}`,
                    content: btoa(newContent),
                    sha: logFile.sha
                });
            } catch (error) {
                if (error.message.includes('404')) {
                    // åˆ›å»ºæ–°çš„æ—¥å¿—æ–‡ä»¶å’Œç›®å½•
                    const logHeader = `# AIç¬”è®°æ•´ç†å¤„ç†æ—¥å¿—\n\nè®°å½•æ ¼å¼ï¼šæ–‡ä»¶å | çŠ¶æ€ | æ—¶é—´æˆ³ | è¯¦ç»†ä¿¡æ¯\n\n---\n\n`;
                    await githubRequest(`/repos/${config.githubUser}/${config.targetRepo}/contents/logs/processing_log.md`, 'PUT', {
                        message: `Create processing log directory and file`,
                        content: btoa(logHeader + logEntry)
                    });
                } else {
                    throw error;
                }
            }
        }

        // å†™å…¥ä¼šè¯æ—¥å¿—åˆ°GitHub
        async function writeSessionLogToGithub() {
            const sessionId = Date.now();
            const sessionLog = Array.from(document.querySelectorAll('.log-entry')).map(el => el.textContent).join('\n');
            
            const sessionLogContent = `# AIç¬”è®°æ•´ç†ä¼šè¯æ—¥å¿— - ${new Date().toLocaleString()}\n\n## ä¼šè¯ID: ${sessionId}\n\n## é…ç½®ä¿¡æ¯\n- æ¨¡å‹: ${config.gptModel}\n- æºä»“åº“: ${config.sourceRepo}\n- ç›®æ ‡ä»“åº“: ${config.targetRepo}\n\n## å¤„ç†ç»Ÿè®¡\n- æ€»æ–‡ä»¶æ•°: ${stats.total}\n- å·²å¤„ç†: ${stats.processed}\n- å·²è·³è¿‡: ${stats.skipped}\n- å¤„ç†å¤±è´¥: ${stats.error}\n\n## è¯¦ç»†æ—¥å¿—\n\n\`\`\`\n${sessionLog}\n\`\`\`\n\n---\n\nç”Ÿæˆæ—¶é—´: ${new Date().toISOString()}`;
            
            try {
                await githubRequest(`/repos/${config.githubUser}/${config.targetRepo}/contents/logs/session_${sessionId}.md`, 'PUT', {
                    message: `Add session log ${sessionId}`,
                    content: btoa(sessionLogContent)
                });
                
                addLog(`ğŸ“ ä¼šè¯æ—¥å¿—å·²ä¿å­˜åˆ°GitHub: logs/session_${sessionId}.md`, 'success');
                return true;
            } catch (error) {
                addLog(`âŒ ä¿å­˜ä¼šè¯æ—¥å¿—å¤±è´¥: ${error.message}`, 'error');
                return false;
            }
        }

        // è·å–å†å²ä¼šè¯æ—¥å¿—åˆ—è¡¨
        async function getSessionLogs() {
            try {
                const logsDir = await githubRequest(`/repos/${config.githubUser}/${config.targetRepo}/contents/logs`);
                const sessionLogs = logsDir.filter(file => file.name.startsWith('session_') && file.name.endsWith('.md'));
                return sessionLogs.sort((a, b) => b.name.localeCompare(a.name)); // æŒ‰æ—¶é—´å€’åº
            } catch (error) {
                if (error.message.includes('404')) {
                    return []; // logsç›®å½•ä¸å­˜åœ¨
                }
                throw error;
            }
        }

        // åˆ›å»ºè¯¦ç»†çš„é”™è¯¯æ—¥å¿—
        async function logErrorToGithub(filename, error, context = '') {
            const errorLogContent = `# é”™è¯¯æ—¥å¿— - ${filename}\n\n## é”™è¯¯ä¿¡æ¯\n${error.message}\n\n## é”™è¯¯å †æ ˆ\n\`\`\`\n${error.stack || 'No stack trace available'}\n\`\`\`\n\n## ä¸Šä¸‹æ–‡ä¿¡æ¯\n${context}\n\n## æ—¶é—´\n${new Date().toISOString()}\n\n## é…ç½®\n- æ¨¡å‹: ${config.gptModel}\n- æºä»“åº“: ${config.sourceRepo}\n- ç›®æ ‡ä»“åº“: ${config.targetRepo}`;
            
            try {
                const errorFileName = `error_${filename.replace(/[^a-zA-Z0-9]/g, '_')}_${Date.now()}.md`;
                await githubRequest(`/repos/${config.githubUser}/${config.targetRepo}/contents/logs/errors/${errorFileName}`, 'PUT', {
                    message: `Add error log for ${filename}`,
                    content: btoa(errorLogContent)
                });
                
                addLog(`ğŸ“ é”™è¯¯è¯¦æƒ…å·²è®°å½•åˆ°GitHub: logs/errors/${errorFileName}`, 'info');
            } catch (logError) {
                addLog(`âš ï¸ æ— æ³•è®°å½•é”™è¯¯æ—¥å¿—: ${logError.message}`, 'warning');
            }
        }

        // å¤„ç†å•ä¸ªç¬”è®°æ–‡ä»¶
        async function processNoteFile(file) {
            addLog(`å¼€å§‹å¤„ç†æ–‡ä»¶: ${file.name}`, 'info');
            
            try {
                // è·å–æ–‡ä»¶å†…å®¹
                const fileData = await githubRequest(`/repos/${config.githubUser}/${config.sourceRepo}/contents/${file.path}`);
                const content = atob(fileData.content);
                
                // è§£æç¬”è®°å†…å®¹
                const lines = content.split('\n');
                const numberedLines = lines.map((text, index) => ({
                    num: index + 1,
                    text: text
                }));

                // æ„å»ºGPTè¯·æ±‚
                const protocol = `ä½ æ˜¯å¢é‡ç¼–è¾‘ Patch åº”ç”¨å™¨åŠ©æ‰‹ï¼Œä¸“é—¨ç”¨äºæ•´ç†å’Œä¼˜åŒ–ç¬”è®°å†…å®¹ã€‚æ¥æ”¶ç”¨æˆ·éœ€æ±‚å’Œå¸¦è¡Œå·çš„ç¬”è®°å†…å®¹ï¼Œè¿”å›çº¯ JSON æ•°ç»„æ“ä½œæŒ‡ä»¤ã€‚

ä½ éœ€è¦åˆ†æç¬”è®°å†…å®¹å¹¶è¿›è¡Œä»¥ä¸‹ä¼˜åŒ–ï¼š
1. ä¸ºé‡è¦æ¦‚å¿µæ·»åŠ è§£é‡Šæ€§æ³¨é‡Š
2. æ•´ç†æ ¼å¼ï¼Œç¡®ä¿Markdownè¯­æ³•æ­£ç¡®
3. ä¸ºæ—¶é—´æˆ³æ ‡é¢˜æ·»åŠ æ›´æ¸…æ™°çš„æè¿°
4. è¡¥å……ç›¸å…³çš„æ ‡ç­¾å’Œåˆ†ç±»
5. ä¿®æ­£è¯­æ³•é”™è¯¯å’Œæ”¹å–„è¡¨è¾¾

æ“ä½œæŒ‡ä»¤æ ¼å¼ï¼š
{"op":"delete_line", "line":L} åˆ é™¤ç¬¬ L è¡Œ
{"op":"delete_block", "start":S, "end":E} åˆ é™¤ç¬¬ S è¡Œè‡³ç¬¬ E è¡Œ
{"op":"replace_line","line":L, "content":"æ–‡æœ¬"} æ›¿æ¢ç¬¬ L è¡Œ
{"op":"insert_line","line":L, "content":"æ–‡æœ¬"} åœ¨ç¬¬ L è¡Œä¹‹å‰æ’å…¥ä¸€è¡Œ
{"op":"insert_block","line":L, "content":["è¡Œ1","è¡Œ2"]} åœ¨ç¬¬ L è¡Œä¹‹å‰æ’å…¥å¤šè¡Œ
{"op":"edit_block","start":S, "end":E, "content":["è¡Œ1","è¡Œ2"]} ç”¨å¤šè¡Œæ›¿æ¢ç¬¬ S åˆ° E è¡Œ

è¯·ç›´æ¥è¿”å›JSONæ ¼å¼çš„æ“ä½œæ•°ç»„ï¼Œä¸è¦åŒ…å«ä»»ä½•å…¶ä»–æ–‡å­—ã€‚`;

                const codeLines = numberedLines.map(item => `${item.num}: ${item.text}`);
                const prompt = `${protocol}\n\nç”¨æˆ·éœ€æ±‚ï¼šä¼˜åŒ–å’Œæ•´ç†è¿™ä¸ªç¬”è®°æ–‡ä»¶ï¼Œæ·»åŠ å¿…è¦çš„æ³¨é‡Šå’Œæ ¼å¼æ”¹è¿›\n\nç›®æ ‡ä»£ç ï¼š\n${codeLines.join('\n')}\n\nè¯·ä¸¥æ ¼æŒ‰ç…§æ ¼å¼è¿”å›JSONæ“ä½œæ•°ç»„ï¼š`;

                // è°ƒç”¨OpenAI API
                const response = await openaiRequest([
                    { role: 'user', content: prompt }
                ], config.gptModel);

                const aiResponse = response.choices[0].message.content;
                let operations;
                
                try {
                    // å°è¯•è§£æJSON
                    const parsed = JSON.parse(aiResponse);
                    operations = parsed.ops || parsed;
                } catch (parseError) {
                    // å¦‚æœç›´æ¥è§£æå¤±è´¥ï¼Œå°è¯•æå–JSONéƒ¨åˆ†
                    const jsonMatch = aiResponse.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        const parsed = JSON.parse(jsonMatch[0]);
                        operations = parsed.ops || parsed;
                    } else {
                        throw new Error('AIè¿”å›çš„æ ¼å¼æ— æ³•è§£æ');
                    }
                }

                // åº”ç”¨æ“ä½œ
                let modifiedLines = [...lines];
                
                // æŒ‰è¡Œå·å€’åºæ’åºæ“ä½œï¼Œé¿å…è¡Œå·åç§»é—®é¢˜
                operations.sort((a, b) => {
                    const lineA = a.line || a.start || 0;
                    const lineB = b.line || b.start || 0;
                    return lineB - lineA;
                });

                for (const op of operations) {
                    switch (op.op) {
                        case 'delete_line':
                            if (op.line > 0 && op.line <= modifiedLines.length) {
                                modifiedLines.splice(op.line - 1, 1);
                            }
                            break;
                        case 'delete_block':
                            if (op.start > 0 && op.end <= modifiedLines.length) {
                                modifiedLines.splice(op.start - 1, op.end - op.start + 1);
                            }
                            break;
                        case 'replace_line':
                            if (op.line > 0 && op.line <= modifiedLines.length) {
                                modifiedLines[op.line - 1] = op.content;
                            }
                            break;
                        case 'insert_line':
                            if (op.line > 0 && op.line <= modifiedLines.length + 1) {
                                modifiedLines.splice(op.line - 1, 0, op.content);
                            }
                            break;
                        case 'insert_block':
                            if (op.line > 0 && op.line <= modifiedLines.length + 1) {
                                modifiedLines.splice(op.line - 1, 0, ...op.content);
                            }
                            break;
                        case 'edit_block':
                            if (op.start > 0 && op.end <= modifiedLines.length) {
                                modifiedLines.splice(op.start - 1, op.end - op.start + 1, ...op.content);
                            }
                            break;
                    }
                }

                const modifiedContent = modifiedLines.join('\n');

                // ä¿å­˜åˆ°ç›®æ ‡ä»“åº“
                try {
                    // æ£€æŸ¥ç›®æ ‡æ–‡ä»¶æ˜¯å¦å­˜åœ¨
                    let targetSha = null;
                    try {
                        const existingFile = await githubRequest(`/repos/${config.githubUser}/${config.targetRepo}/contents/${file.path}`);
                        targetSha = existingFile.sha;
                    } catch (e) {
                        // æ–‡ä»¶ä¸å­˜åœ¨ï¼Œè¿™æ˜¯æ­£å¸¸çš„
                    }

                    await githubRequest(`/repos/${config.githubUser}/${config.targetRepo}/contents/${file.path}`, 'PUT', {
                        message: `AIæ•´ç†ç¬”è®°: ${file.name}`,
                        content: btoa(modifiedContent),
                        sha: targetSha
                    });

                    // æ›´æ–°å¤„ç†æ—¥å¿—
                    await updateProcessingLog(file.name, 'success', `åº”ç”¨äº†${operations.length}ä¸ªç¼–è¾‘æ“ä½œ`);
                    
                    addLog(`âœ… æˆåŠŸå¤„ç†: ${file.name}`, 'success');
                    stats.processed++;
                    
                } catch (saveError) {
                    await updateProcessingLog(file.name, 'failed', `ä¿å­˜å¤±è´¥: ${saveError.message}`);
                    await logErrorToGithub(file.name, saveError, 'æ–‡ä»¶ä¿å­˜é˜¶æ®µ');
                    addLog(`âŒ ä¿å­˜å¤±è´¥: ${file.name} - ${saveError.message}`, 'error');
                    stats.error++;
                }

            } catch (error) {
                await updateProcessingLog(file.name, 'error', `å¤„ç†å¤±è´¥: ${error.message}`);
                await logErrorToGithub(file.name, error, 'æ–‡ä»¶å¤„ç†é˜¶æ®µ');
                addLog(`âŒ å¤„ç†å¤±è´¥: ${file.name} - ${error.message}`, 'error');
                stats.error++;
            }
        }

        // ä¸»å¤„ç†å‡½æ•°
        async function startProcessing() {
            if (isProcessing) return;

            // éªŒè¯é…ç½®
            saveConfig();
            if (!config.githubToken || !config.openaiKey || !config.githubUser || !config.sourceRepo || !config.targetRepo) {
                addLog('âŒ è¯·å¡«å†™å®Œæ•´çš„é…ç½®ä¿¡æ¯', 'error');
                return;
            }

            isProcessing = true;
            document.getElementById('processBtn').disabled = true;
            updateStatus('æ­£åœ¨å¤„ç†...', 'processing');
            
            // é‡ç½®ç»Ÿè®¡
            stats = { total: 0, processed: 0, skipped: 0, error: 0 };
            updateStats();

            try {
                addLog('ğŸš€ å¼€å§‹æ™ºèƒ½ç¬”è®°æ•´ç†æµç¨‹', 'info');
                
                // è·å–å¤„ç†æ—¥å¿—
                const processingLog = await getProcessingLog();
                processedLog = new Set(processingLog.map(line => {
                    const parts = line.split(' | ');
                    return parts[0]; // æå–æ–‡ä»¶åéƒ¨åˆ†
                }).filter(filename => filename && filename.trim()));
                
                addLog(`ğŸ“‹ å·²æ‰¾åˆ° ${processedLog.size} ä¸ªå·²å¤„ç†æ–‡ä»¶è®°å½•`, 'info');

                // è·å–æºä»“åº“çš„æ‰€æœ‰æ–‡ä»¶
                const repoContents = await githubRequest(`/repos/${config.githubUser}/${config.sourceRepo}/contents`);
                const mdFiles = [];

                // é€’å½’è·å–æ‰€æœ‰.mdæ–‡ä»¶
                async function collectMdFiles(contents, path = '') {
                    for (const item of contents) {
                        if (item.type === 'file' && item.name.endsWith('.md')) {
                            mdFiles.push({
                                name: item.name,
                                path: item.path,
                                url: item.url
                            });
                        } else if (item.type === 'dir') {
                            const subContents = await githubRequest(`/repos/${config.githubUser}/${config.sourceRepo}/contents/${item.path}`);
                            await collectMdFiles(subContents, item.path);
                        }
                    }
                }

                await collectMdFiles(repoContents);
                
                // è¿‡æ»¤æœªå¤„ç†çš„æ–‡ä»¶
                const unprocessedFiles = mdFiles.filter(file => !processedLog.has(file.name));
                
                stats.total = mdFiles.length;
                stats.skipped = processedLog.size;
                updateStats();

                addLog(`ğŸ“ æ‰¾åˆ° ${stats.total} ä¸ªMarkdownæ–‡ä»¶ï¼Œå…¶ä¸­ ${unprocessedFiles.length} ä¸ªå¾…å¤„ç†`, 'info');

                if (unprocessedFiles.length === 0) {
                    addLog('âœ… æ‰€æœ‰æ–‡ä»¶éƒ½å·²å¤„ç†å®Œæˆ', 'success');
                    updateStatus('æ‰€æœ‰æ–‡ä»¶å·²å¤„ç†', 'ready');
                    return;
                }

                // å¤„ç†æ¯ä¸ªæ–‡ä»¶
                for (let i = 0; i < unprocessedFiles.length; i++) {
                    const file = unprocessedFiles[i];
                    const progress = ((i + 1) / unprocessedFiles.length) * 100;
                    
                    updateProgress(progress);
                    updateStatus(`å¤„ç†ä¸­... (${i + 1}/${unprocessedFiles.length})`, 'processing');
                    
                    await processNoteFile(file);
                    updateStats();
                    
                    // æ·»åŠ å»¶è¿Ÿé¿å…APIé™åˆ¶
                    if (i < unprocessedFiles.length - 1) {
                        await new Promise(resolve => setTimeout(resolve, 1000));
                    }
                }

                addLog('ğŸ‰ æ™ºèƒ½ç¬”è®°æ•´ç†å®Œæˆï¼', 'success');
                updateStatus('å¤„ç†å®Œæˆ', 'ready');
                updateProgress(100);

                // ä¿å­˜ä¼šè¯æ—¥å¿—åˆ°GitHub
                addLog('ğŸ“ æ­£åœ¨ä¿å­˜ä¼šè¯æ—¥å¿—åˆ°GitHub...', 'info');
                await writeSessionLogToGithub();

            } catch (error) {
                addLog(`âŒ å¤„ç†è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯: ${error.message}`, 'error');
                await logErrorToGithub('main_process', error, 'ä¸»å¤„ç†æµç¨‹');
                updateStatus('å¤„ç†å‡ºé”™', 'error');
            } finally {
                isProcessing = false;
                document.getElementById('processBtn').disabled = false;
            }
        }

        // å·¥å…·å‡½æ•°
        function validateConfig() {
            const required = ['githubToken', 'openaiKey', 'githubUser', 'sourceRepo', 'targetRepo'];
            for (const field of required) {
                if (!config[field] || config[field].trim() === '') {
                    return false;
                }
            }
            return true;
        }

        // é”™è¯¯å¤„ç†
        window.addEventListener('error', function(e) {
            addLog(`ğŸ’¥ ç³»ç»Ÿé”™è¯¯: ${e.message}`, 'error');
        });

        // æ·»åŠ é”®ç›˜å¿«æ·é”®
        document.addEventListener('keydown', function(e) {
            if (e.ctrlKey || e.metaKey) {
                switch(e.key) {
                    case 's':
                        e.preventDefault();
                        saveConfig();
                        break;
                    case 'Enter':
                        if (!isProcessing) {
                            e.preventDefault();
                            startProcessing();
                        }
                        break;
                }
            }
        });

        // é¡µé¢ç¦»å¼€å‰æé†’
        window.addEventListener('beforeunload', function(e) {
            if (isProcessing) {
                e.preventDefault();
                e.returnValue = 'æ­£åœ¨å¤„ç†æ–‡ä»¶ï¼Œç¡®å®šè¦ç¦»å¼€å—ï¼Ÿ';
                return e.returnValue;
            }
        });

        // è‡ªåŠ¨ä¿å­˜é…ç½®åŠŸèƒ½
        function setupAutoSave() {
            const inputs = document.querySelectorAll('input, select');
            inputs.forEach(input => {
                input.addEventListener('blur', function() {
                    if (this.value.trim()) {
                        saveConfig();
                    }
                });
            });
        }

        // åˆå§‹åŒ–è‡ªåŠ¨ä¿å­˜
        setupAutoSave();

        // æ·»åŠ æ‹–æ‹½æ–‡ä»¶æ”¯æŒï¼ˆæœªæ¥æ‰©å±•ï¼‰
        document.addEventListener('dragover', function(e) {
            e.preventDefault();
        });

        document.addEventListener('drop', function(e) {
            e.preventDefault();
            addLog('ğŸš§ æ‹–æ‹½ä¸Šä¼ åŠŸèƒ½å¼€å‘ä¸­...', 'warning');
        });

        // ä¸»é¢˜åˆ‡æ¢åŠŸèƒ½ï¼ˆå¯é€‰ï¼‰
        function toggleTheme() {
            document.body.classList.toggle('dark-theme');
            addLog('ğŸ¨ ä¸»é¢˜å·²åˆ‡æ¢', 'info');
        }

        // æ‰¹é‡æ“ä½œæç¤º
        function showBatchTips() {
            addLog('ğŸ’¡ æç¤ºï¼šå»ºè®®åœ¨ç½‘ç»œç¨³å®šæ—¶è¿›è¡Œæ‰¹é‡å¤„ç†', 'info');
            addLog('ğŸ’¡ æç¤ºï¼šå¤§é‡æ–‡ä»¶å¤„ç†æ—¶è¯·ä¿æŒé¡µé¢å¼€å¯', 'info');
            addLog('ğŸ’¡ æç¤ºï¼šå¯ä½¿ç”¨Ctrl+Så¿«é€Ÿä¿å­˜é…ç½®', 'info');
        }

        // å¯åŠ¨æ—¶æ˜¾ç¤ºæç¤º
        setTimeout(showBatchTips, 2000);

        // APIé…é¢æ£€æŸ¥ï¼ˆå¯é€‰åŠŸèƒ½ï¼‰
        async function checkApiQuota() {
            try {
                // æ£€æŸ¥GitHub APIå‰©ä½™é…é¢
                const rateLimit = await fetch('https://api.github.com/rate_limit', {
                    headers: {
                        'Authorization': `token ${config.githubToken}`
                    }
                });
                
                if (rateLimit.ok) {
                    const data = await rateLimit.json();
                    const remaining = data.rate.remaining;
                    addLog(`GitHub APIå‰©ä½™é…é¢: ${remaining}`, remaining > 100 ? 'info' : 'warning');
                }
            } catch (error) {
                // é™é»˜å¤„ç†é…é¢æ£€æŸ¥é”™è¯¯
            }
        }

        // å¢å¼ºçš„é”™è¯¯é‡è¯•æœºåˆ¶
        async function retryOperation(operation, maxRetries = 3, delay = 1000) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    return await operation();
                } catch (error) {
                    if (i === maxRetries - 1) throw error;
                    addLog(`âš ï¸ æ“ä½œå¤±è´¥ï¼Œ${delay/1000}ç§’åé‡è¯•... (${i+1}/${maxRetries})`, 'warning');
                    await new Promise(resolve => setTimeout(resolve, delay));
                    delay *= 2; // æŒ‡æ•°é€€é¿
                }
            }
        }

        // æ–‡ä»¶å¤§å°æ£€æŸ¥
        function checkFileSize(content, filename, maxSize = 1024 * 1024) { // 1MBé™åˆ¶
            const size = new Blob([content]).size;
            if (size > maxSize) {
                addLog(`âš ï¸ æ–‡ä»¶ ${filename} è¿‡å¤§ (${(size/1024/1024).toFixed(2)}MB)ï¼Œå¯èƒ½å½±å“å¤„ç†æ€§èƒ½`, 'warning');
                return false;
            }
            return true;
        }

        // å†…å®¹è´¨é‡æ£€æŸ¥
        function validateNoteContent(content, filename) {
            const lines = content.split('\n');
            const hasTimeHeader = lines.some(line => /^##\s+\d{4}\/\d{2}\/\d{2}/.test(line));
            
            if (!hasTimeHeader) {
                addLog(`âš ï¸ æ–‡ä»¶ ${filename} å¯èƒ½ä¸æ˜¯æ ‡å‡†çš„æ—¥è®°æ ¼å¼`, 'warning');
            }
            
            if (lines.length < 3) {
                addLog(`âš ï¸ æ–‡ä»¶ ${filename} å†…å®¹è¿‡å°‘ï¼Œå¯èƒ½ä¸éœ€è¦AIå¤„ç†`, 'warning');
                return false;
            }
            
            return true;
        }

        // å¯¼å‡ºå¤„ç†æŠ¥å‘Š
        function exportReport() {
            const report = {
                timestamp: new Date().toISOString(),
                config: {
                    model: config.gptModel,
                    sourceRepo: config.sourceRepo,
                    targetRepo: config.targetRepo
                },
                stats: stats,
                logs: Array.from(document.querySelectorAll('.log-entry')).map(el => el.textContent)
            };
            
            const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `note-processing-report-${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            addLog('ğŸ“Š å¤„ç†æŠ¥å‘Šå·²å¯¼å‡º', 'success');
        }

        // æŸ¥çœ‹å†å²ä¼šè¯æ—¥å¿—
        async function viewHistoryLogs() {
            try {
                addLog('ğŸ” æ­£åœ¨è·å–å†å²ä¼šè¯æ—¥å¿—...', 'info');
                const sessionLogs = await getSessionLogs();
                
                if (sessionLogs.length === 0) {
                    addLog('ğŸ“­ æš‚æ— å†å²ä¼šè¯æ—¥å¿—', 'info');
                    return;
                }

                addLog(`ğŸ“š æ‰¾åˆ° ${sessionLogs.length} ä¸ªå†å²ä¼šè¯æ—¥å¿—:`, 'info');
                sessionLogs.slice(0, 10).forEach((log, index) => {
                    const sessionId = log.name.replace('session_', '').replace('.md', '');
                    const date = new Date(parseInt(sessionId)).toLocaleString();
                    addLog(`  ${index + 1}. ä¼šè¯ ${sessionId} - ${date}`, 'info');
                });

                if (sessionLogs.length > 10) {
                    addLog(`  ... è¿˜æœ‰ ${sessionLogs.length - 10} ä¸ªå†å²ä¼šè¯`, 'info');
                }

                document.getElementById('sessionCount').textContent = sessionLogs.length;
            } catch (error) {
                addLog(`âŒ è·å–å†å²æ—¥å¿—å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // ä¿å­˜å½“å‰ä¼šè¯
        async function saveCurrentSession() {
            if (Array.from(document.querySelectorAll('.log-entry')).length <= 1) {
                addLog('âš ï¸ å½“å‰ä¼šè¯æ— å†…å®¹å¯ä¿å­˜', 'warning');
                return;
            }

            addLog('ğŸ’¾ æ­£åœ¨ä¿å­˜å½“å‰ä¼šè¯åˆ°GitHub...', 'info');
            const success = await writeSessionLogToGithub();
            
            if (success) {
                document.getElementById('logStatus').textContent = 'âœ…';
                // æ›´æ–°ä¼šè¯è®¡æ•°
                viewHistoryLogs();
            } else {
                document.getElementById('logStatus').textContent = 'âŒ';
            }
        }

        // æ¸…ç©ºå½“å‰æ—¥å¿—
        function clearCurrentLogs() {
            const logContainer = document.getElementById('logContainer');
            logContainer.innerHTML = '<div class="log-entry log-info">æ—¥å¿—å·²æ¸…ç©ºï¼Œç­‰å¾…æ–°çš„æ“ä½œ...</div>';
            addLog('ğŸ—‘ï¸ å½“å‰æ—¥å¿—å·²æ¸…ç©º', 'info');
        }

        // æ£€æŸ¥GitHubæ—¥å¿—ç›®å½•çŠ¶æ€
        async function checkLogStatus() {
            try {
                const sessionLogs = await getSessionLogs();
                document.getElementById('sessionCount').textContent = sessionLogs.length;
                
                // æ£€æŸ¥é”™è¯¯æ—¥å¿—
                try {
                    const errorLogs = await githubRequest(`/repos/${config.githubUser}/${config.targetRepo}/contents/logs/errors`);
                    document.getElementById('errorCount').textContent = errorLogs.length;
                } catch (e) {
                    document.getElementById('errorCount').textContent = '0';
                }
                
                document.getElementById('logStatus').textContent = 'âœ…';
            } catch (error) {
                document.getElementById('logStatus').textContent = 'âŒ';
            }
        }

        // å®šæœŸæ£€æŸ¥æ—¥å¿—çŠ¶æ€
        setInterval(() => {
            if (config.githubToken && config.githubUser && config.targetRepo) {
                checkLogStatus();
            }
        }, 30000); // æ¯30ç§’æ£€æŸ¥ä¸€æ¬¡

        // æ·»åŠ å¯¼å‡ºæŒ‰é’®åˆ°ç»Ÿè®¡åŒºåŸŸ
        // document.querySelector('.stats-grid').insertAdjacentHTML('beforeend', `
        //     <div class="stat-card" style="cursor: pointer;" onclick="exportReport()">
        //         <span class="stat-number">ğŸ“Š</span>
        //         <div class="stat-label">å¯¼å‡ºæŠ¥å‘Š</div>
        //     </div>
        // `);
    </script>
</body>
</html>
