# 聊天备忘录 - 2025年07月18日

---

## 2025/07/18 10:55:59

```yaml
iso_datetime: 2025-07-18T10:55:59+00:00
type: code
lang: python
function_call:
  name: find_markers_with_sunday
  description: 使用Sunday算法在文本中查找标记对并返回其索引范围
  inputs:
    - text: str
    - start_marker: str
    - end_marker: str
  outputs:
    - (start_index, end_index): tuple 或 None
```

```
def find_markers_with_sunday(text, start_marker, end_marker):
    """
    使用Sunday算法在文本中查找标记对并返回其索引范围
    
    参数:
        text: 要搜索的长文本
        start_marker: 起始标记字符串
        end_marker: 结束标记字符串
        
    返回:
        如果找到两个标记，返回元组(start_index, end_index)
        start_index是start_marker首字符的索引
        end_index是end_marker末字符的索引
        如果未找到，返回None
    """
    def sunday_search(haystack, needle):
        """Sunday算法实现"""
        if not needle or not haystack or len(needle) > len(haystack):
            return -1
        
        offset = {}
        len_needle = len(needle)
        for i in range(len_needle):
            offset[needle[i]] = len_needle - i
        
        i = 0
        len_haystack = len(haystack)
        while i <= len_haystack - len_needle:
            match = True
            for j in range(len_needle):
                if haystack[i + j] != needle[j]:
                    match = False
                    break
            
            if match:
                return i
            
            if i + len_needle >= len_haystack:
                break
            next_char = haystack[i + len_needle]
            i += offset.get(next_char, len_needle + 1)
        
        return -1
    
    # 查找起始标记
    start_pos = sunday_search(text, start_marker)
    if start_pos == -1:
        return None
    
    # 在起始标记之后查找结束标记
    search_area = text[start_pos + len(start_marker):]
    end_pos_in_search = sunday_search(search_area, end_marker)
    if end_pos_in_search == -1:
        return None
    
    # 计算结束标记在原始文本中的位置
    end_pos = start_pos + len(start_marker) + end_pos_in_search + len(end_marker) - 1
    
    return (start_pos, end_pos),text[start_pos:end_pos+1]


# 测试示例
if __name__ == "__main__":
    # 示例文本
    sample_text = """
    这是一段示例文本，包含多个标记。
    开始标记是<start>，结束标记是<end>。
    我们要提取<start>这是需要提取的内容<end>之间的部分。
    这里还有另一对标记<start>另一段内容<end>。
    """
    
    # 定义标记
    start_tag = "这是一段示例文本，包含多"
    end_tag = "记<st"
    
    # 查找第一对标记
    result = find_markers_with_sunday(sample_text, start_tag, end_tag)
    if result:
        print(result[0],'\n',result[1])


# 你是一个代码修改大师。现在请你根据[用户要求]，修改这段代码

```

---

## 2025/07/18 11:44:31

```yaml
iso_datetime: 2025-07-18T11:44:31+00:00
summary: 代码修改大师的思路
```

```
我在右侧 Canvas 里放了一份 code_text_separator.py 的示例脚本，核心思路和用法如下（你可以随时在对话中要求修改或继续扩展脚本）：

思路概要
轻量启发式判别

统计关键词（def / class / import / function…）、分号、括号、运算符等典型编程符号的密度。

结合 UTF‑8 范围判断：若英文占比高且符号密度高，则倾向判为代码。

可选 GPT 微调用

只有当启发式评分落在“灰区”时，才把那一小段文字（通常 < 50 字符）丢给 GPT 让它回答 “code” 或 “text”，最大限度节省 token。

你可以在脚本里配置 OPENAI_API_KEY 和 model，甚至把 “代码/指令” 定义得更细（如 SQL、Bash 等）。

输出格式

按段落重写：TEXT 段直接留原文，CODE 段包进 代码块。

默认写回 formatted.md，也可 --stdout 直接打印。

```

---
